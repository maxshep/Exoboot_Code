import threading
from typing import Type
import config_util

from concurrent import futures
import grpc
import Message_pb2
import Message_pb2_grpc

class ControllerCommunication(threading.Thread):
    def __init__(self,
                 config: Type[config_util.ConfigurableConstants],
                 name='communication-thread'):
        '''This class runs in parallel to the main loop, it runs the server :{Which listens to the new control parameter generated by the optimizer}
        and updates the config file with the new control parameters
        '''
        super().__init__(name=name)
        self.daemon = True  # Thread property
        self.config = config
        self.start()  # Starts the run() function
    
    class GenerateControlParameters (Message_pb2_grpc.GenerateControlParametersServicer):
        def __init__(self,ControllerCommunication):
            self.ControllerCommunication = ControllerCommunication
        def ControlParameterRequest(self,request, context):
            self.ControllerCommunication.config.RISE_FRACTION = request.control_parameters[0]
            self.ControllerCommunication.config.PEAK_FRACTION = request.control_parameters[1]
            self.ControllerCommunication.config.FALL_FRACTION = request.control_parameters[2]
            self.ControllerCommunication.config.PEAK_TORQUE = request.control_parameters[3]
            self.ControllerCommunication.config.SPLINE_BIAS = request.control_parameters[4]
            return Message_pb2.Null()

    def s3(self):
        server3 = grpc.server(futures.ThreadPoolExecutor(max_workers=10))
        Message_pb2_grpc.add_GenerateControlParametersServicer_to_server(self.GenerateControlParameters(self), server3)
        server3.add_insecure_port('0.0.0.0:80080')
        server3.start()
        server3.wait_for_termination()

    # This run function overrides the run() function in threading.Thread
    def run(self):
        while True:
            self.s3()
